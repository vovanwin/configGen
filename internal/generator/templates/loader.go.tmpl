// Code generated by configgen. DO NOT EDIT.
// Код сгенерирован configgen. НЕ РЕДАКТИРОВАТЬ.

package {{ .Package }}

import (
	"fmt"
	"os"
	"path/filepath"
	"strings"
	"sync"

	"github.com/knadh/koanf/parsers/toml/v2"
	"github.com/knadh/koanf/providers/file"
{{- if .WithEnvOverride }}
	kenv "github.com/knadh/koanf/providers/env"
{{- end }}
	"github.com/knadh/koanf/v2"
)

var (
	allConfigs map[Environment]*Config
	configMu   sync.RWMutex
	currentEnv Environment
)

// LoadOptions настраивает загрузку конфигурации
type LoadOptions struct {
	// ConfigDir директория с файлами конфигурации
	ConfigDir string

	// Environment окружение для загрузки (local, dev, stg, prod)
	// Если пусто, читается из переменной окружения {{ .EnvPrefix }}
	Environment Environment

	// EnableOverride позволяет override.toml переопределять значения текущего окружения
	EnableOverride bool
{{- if .WithEnvOverride }}

	// EnableEnv позволяет env vars переопределять значения из файлов
	// Разделитель секций — двойное подчёркивание (__), одинарное (_) сохраняется
	// Пример: {{ .EnvVarPrefix }}SERVER__HOST=localhost переопределяет server.host
	// Пример: {{ .EnvVarPrefix }}DB__MAX_OPEN_CONNS=10 переопределяет db.max_open_conns
	EnableEnv bool
{{- end }}
}
{{- if .WithFlags }}

// LoadResult результат загрузки конфигурации с опциональными флагами
type LoadResult struct {
	Config *Config
	Flags  *Flags // nil если секция [flags] не найдена в config файлах
}
{{- end }}

// Load загружает все конфигурации окружений и выбирает нужную
// Порядок мержа для каждого env: value.toml -> config_{env}.toml
// Для текущего env дополнительно: -> override.toml (если EnableOverride=true)
func Load(opts *LoadOptions) (*Config, error) {
	if opts == nil {
		opts = &LoadOptions{
			ConfigDir:      "./configs",
			EnableOverride: true,
		}
	}

	env := opts.Environment
	if env == "" {
		envStr := os.Getenv("{{ .EnvPrefix }}")
		if envStr == "" {
			envStr = "dev"
		}
		env = Environment(envStr)
	}

	valuePath := filepath.Join(opts.ConfigDir, "value.toml")
	hasValue := fileExists(valuePath)

	// Находим все config_*.toml (каждый = отдельное окружение)
	matches, err := filepath.Glob(filepath.Join(opts.ConfigDir, "config_*.toml"))
	if err != nil {
		return nil, fmt.Errorf("поиск конфигов: %w", err)
	}

	configs := make(map[Environment]*Config)

	needReload := opts.EnableOverride{{- if .WithEnvOverride }} || opts.EnableEnv{{- end }}

	for _, match := range matches {
		envName := envFromFilename(filepath.Base(match))

		if needReload && Environment(envName) == env {
			continue
		}

		cfg, err := loadSingle(valuePath, hasValue, match)
		if err != nil {
			return nil, err
		}
		cfg.Env = Environment(envName)
		configs[cfg.Env] = cfg
	}

	// Для текущего окружения: value.toml → config_{env}.toml → override.toml{{- if .WithEnvOverride }} → env vars{{- end }}
	if needReload {
		envPath := filepath.Join(opts.ConfigDir, fmt.Sprintf("config_%s.toml", env))
		if fileExists(envPath) {
			k := koanf.New(".")

			if hasValue {
				if err := k.Load(file.Provider(valuePath), toml.Parser()); err != nil {
					return nil, fmt.Errorf("загрузка value.toml: %w", err)
				}
			}

			if err := k.Load(file.Provider(envPath), toml.Parser()); err != nil {
				return nil, fmt.Errorf("загрузка config_%s.toml: %w", env, err)
			}

			if opts.EnableOverride {
				overridePath := filepath.Join(opts.ConfigDir, "override.toml")
				if fileExists(overridePath) {
					if err := k.Load(file.Provider(overridePath), toml.Parser()); err != nil {
						return nil, fmt.Errorf("загрузка override.toml: %w", err)
					}
				}
			}
{{- if .WithEnvOverride }}

			if opts.EnableEnv {
				envPrefix := "{{ .EnvVarPrefix }}"
				if err := k.Load(kenv.Provider(envPrefix, ".", func(s string) string {
					// {{ .EnvVarPrefix }}SERVER__HOST -> server.host
					// {{ .EnvVarPrefix }}DB__MAX_IDLE_TIME -> db.max_idle_time
					s = strings.TrimPrefix(s, envPrefix)
					s = strings.ToLower(s)
					s = strings.ReplaceAll(s, "__", ".")
					return s
				}), nil); err != nil {
					return nil, fmt.Errorf("загрузка env vars: %w", err)
				}
			}
{{- end }}

			// Удаляем секцию flags перед unmarshal в Config
			k.Delete("flags")

			cfg := &Config{}
			if err := k.UnmarshalWithConf("", cfg, koanf.UnmarshalConf{Tag: "toml"}); err != nil {
				return nil, fmt.Errorf("декодирование конфига: %w", err)
			}
			cfg.Env = env
			configs[env] = cfg
		}
	}

	current := configs[env]
	if current == nil {
		return nil, fmt.Errorf("конфиг для окружения %q не найден", env)
	}

	configMu.Lock()
	allConfigs = configs
	currentEnv = env
	configMu.Unlock()

	return current, nil
}
{{- if .WithFlags }}

// LoadWithFlags загружает конфигурацию и извлекает локальные значения флагов из секции [flags]
func LoadWithFlags(opts *LoadOptions) (*LoadResult, error) {
	if opts == nil {
		opts = &LoadOptions{
			ConfigDir:      "./configs",
			EnableOverride: true,
		}
	}

	cfg, err := Load(opts)
	if err != nil {
		return nil, err
	}

	env := opts.Environment
	if env == "" {
		env = GetEnv()
	}

	// Собираем значения флагов из config файлов текущего окружения
	flagOverrides := loadFlagOverrides(opts.ConfigDir, env)

	var flags *Flags
	if len(flagOverrides) > 0 {
		// Мержим: дефолты + override из конфигов
		merged := DefaultFlagValues()
		for k, v := range flagOverrides {
			merged[k] = v
		}
		flags = NewFlags(NewMemoryStore(merged))
	} else {
		flags = NewFlags(NewMemoryStore(DefaultFlagValues()))
	}

	return &LoadResult{Config: cfg, Flags: flags}, nil
}

// loadFlagOverrides загружает секцию [flags] из config файлов
func loadFlagOverrides(configDir string, env Environment) map[string]any {
	k := koanf.New(".")

	// Загружаем config_{env}.toml для извлечения [flags]
	envPath := filepath.Join(configDir, fmt.Sprintf("config_%s.toml", env))
	if fileExists(envPath) {
		_ = k.Load(file.Provider(envPath), toml.Parser())
	}

	raw := k.Get("flags")
	if raw == nil {
		return nil
	}

	m, ok := raw.(map[string]any)
	if !ok {
		return nil
	}
	return m
}
{{- end }}

// loadSingle загружает один конфиг: value.toml + config_{env}.toml
func loadSingle(valuePath string, hasValue bool, envPath string) (*Config, error) {
	k := koanf.New(".")

	if hasValue {
		if err := k.Load(file.Provider(valuePath), toml.Parser()); err != nil {
			return nil, fmt.Errorf("загрузка value.toml: %w", err)
		}
	}

	if err := k.Load(file.Provider(envPath), toml.Parser()); err != nil {
		return nil, fmt.Errorf("загрузка %s: %w", filepath.Base(envPath), err)
	}

	// Удаляем секцию flags перед unmarshal
	k.Delete("flags")

	cfg := &Config{}
	if err := k.UnmarshalWithConf("", cfg, koanf.UnmarshalConf{Tag: "toml"}); err != nil {
		return nil, fmt.Errorf("декодирование %s: %w", filepath.Base(envPath), err)
	}
	return cfg, nil
}

func envFromFilename(name string) string {
	return strings.TrimSuffix(strings.TrimPrefix(name, "config_"), ".toml")
}

func fileExists(path string) bool {
	_, err := os.Stat(path)
	return err == nil
}

// MustLoad загружает конфигурацию или паникует при ошибке
func MustLoad(opts *LoadOptions) *Config {
	cfg, err := Load(opts)
	if err != nil {
		panic(fmt.Sprintf("ошибка загрузки конфига: %v", err))
	}
	return cfg
}

// Get возвращает текущий конфиг (потокобезопасно)
func Get() *Config {
	configMu.RLock()
	defer configMu.RUnlock()
	return allConfigs[currentEnv]
}

// GetEnv возвращает текущее окружение
func GetEnv() Environment {
	configMu.RLock()
	defer configMu.RUnlock()
	return currentEnv
}

// GetAll возвращает конфиги всех окружений
func GetAll() map[Environment]*Config {
	configMu.RLock()
	defer configMu.RUnlock()
	return allConfigs
}

// IsProduction возвращает true если работаем в production
func IsProduction() bool {
	return GetEnv() == EnvProduction
}

// IsStg возвращает true если работаем в staging
func IsStg() bool {
	return GetEnv() == EnvStaging
}

// IsLocal возвращает true если работаем локально
func IsLocal() bool {
	return GetEnv() == EnvLocal
}
