// Code generated by configgen. DO NOT EDIT.
// Код сгенерирован configgen. НЕ РЕДАКТИРОВАТЬ.

package {{ .Package }}

import (
	"fmt"
	"os"
	"path/filepath"
	"sync"

	"github.com/knadh/koanf/parsers/toml/v2"
	"github.com/knadh/koanf/providers/file"
	"github.com/knadh/koanf/v2"
)

// Environment представляет окружение развертывания
type Environment string

const (
	EnvLocal      Environment = "local"
	EnvDev        Environment = "dev"
	EnvStaging    Environment = "stg"
	EnvProduction Environment = "prod"
)

var (
	globalConfig *Config
	globalValue  *Value
	configMu     sync.RWMutex
	currentEnv   Environment
)

// LoadOptions настраивает загрузку конфигурации
type LoadOptions struct {
	// ConfigDir директория с файлами конфигурации
	ConfigDir string

	// Environment окружение для загрузки (local, dev, stg, prod)
	// Если пусто, читается из переменной окружения {{ .EnvPrefix }}
	Environment Environment

	// EnableLocalOverride позволяет config_local.toml переопределять значения
	EnableLocalOverride bool
}

// Load загружает конфигурацию с заданными опциями
func Load(opts *LoadOptions) (*Config, error) {
	if opts == nil {
		opts = &LoadOptions{
			ConfigDir:           "./configs",
			EnableLocalOverride: true,
		}
	}

	env := opts.Environment
	if env == "" {
		envStr := os.Getenv("{{ .EnvPrefix }}")
		if envStr == "" {
			envStr = "dev"
		}
		env = Environment(envStr)
	}

	configMu.Lock()
	defer configMu.Unlock()

	currentEnv = env

	// Загружаем value.toml (константы)
	valuePath := filepath.Join(opts.ConfigDir, "value.toml")
	if _, err := os.Stat(valuePath); err == nil {
		kv := koanf.New(".")
		if err := kv.Load(file.Provider(valuePath), toml.Parser()); err != nil {
			return nil, fmt.Errorf("загрузка value.toml: %w", err)
		}
		value := &Value{}
		if err := kv.UnmarshalWithConf("", value, koanf.UnmarshalConf{Tag: "toml"}); err != nil {
			return nil, fmt.Errorf("декодирование value.toml: %w", err)
		}
		globalValue = value
	}

	// Загружаем config_{env}.toml + config_local.toml с автоматическим мержем
	k := koanf.New(".")

	envPath := filepath.Join(opts.ConfigDir, fmt.Sprintf("config_%s.toml", env))
	if err := k.Load(file.Provider(envPath), toml.Parser()); err != nil {
		return nil, fmt.Errorf("загрузка config_%s.toml: %w", env, err)
	}

	if opts.EnableLocalOverride {
		localPath := filepath.Join(opts.ConfigDir, "config_local.toml")
		if _, err := os.Stat(localPath); err == nil {
			if err := k.Load(file.Provider(localPath), toml.Parser()); err != nil {
				return nil, fmt.Errorf("загрузка config_local.toml: %w", err)
			}
		}
	}

	cfg := &Config{}
	if err := k.UnmarshalWithConf("", cfg, koanf.UnmarshalConf{Tag: "toml"}); err != nil {
		return nil, fmt.Errorf("декодирование конфига: %w", err)
	}

	globalConfig = cfg
	return cfg, nil
}

// MustLoad загружает конфигурацию или паникует при ошибке
func MustLoad(opts *LoadOptions) *Config {
	cfg, err := Load(opts)
	if err != nil {
		panic(fmt.Sprintf("ошибка загрузки конфига: %v", err))
	}
	return cfg
}

// Get возвращает текущий конфиг (потокобезопасно)
func Get() *Config {
	configMu.RLock()
	defer configMu.RUnlock()
	return globalConfig
}

// GetValue возвращает константные значения (потокобезопасно)
func GetValue() *Value {
	configMu.RLock()
	defer configMu.RUnlock()
	return globalValue
}

// GetEnv возвращает текущее окружение
func GetEnv() Environment {
	configMu.RLock()
	defer configMu.RUnlock()
	return currentEnv
}

// IsProduction возвращает true если работаем в production
func IsProduction() bool {
	return GetEnv() == EnvProduction
}

// IsDevelopment возвращает true если работаем в dev или local
func IsDevelopment() bool {
	env := GetEnv()
	return env == EnvDev || env == EnvLocal
}
