// Code generated by configgen. DO NOT EDIT.
// Код сгенерирован configgen. НЕ РЕДАКТИРОВАТЬ.

package config

import (
	"fmt"
	"os"
	"path/filepath"
	"sync"

	"github.com/BurntSushi/toml"
)

// Environment представляет окружение развертывания
type Environment string

const (
	EnvLocal      Environment = "local"
	EnvDev        Environment = "dev"
	EnvStaging    Environment = "stg"
	EnvProduction Environment = "prod"
)

// Source указывает откуда пришло значение конфига
type Source int

const (
	SourceDefault Source = iota // Из value.toml
	SourceEnv                   // Из config_{env}.toml
	SourceLocal                 // Из config_local.toml
	SourceVault                 // Из Vault (будущее)
	SourceRTC                   // Из RTC (будущее)
)

var (
	globalConfig *Config
	globalValue  *Value
	configMu     sync.RWMutex
	currentEnv   Environment
)

// LoadOptions настраивает загрузку конфигурации
type LoadOptions struct {
	// ConfigDir директория с файлами конфигурации
	ConfigDir string

	// Environment окружение для загрузки (local, dev, stg, prod)
	// Если пусто, читается из переменной окружения APP_ENV
	Environment Environment

	// EnableLocalOverride позволяет config_local.toml переопределять значения
	EnableLocalOverride bool
}

// DefaultLoadOptions возвращает настройки по умолчанию
func DefaultLoadOptions() *LoadOptions {
	return &LoadOptions{
		ConfigDir:           "./configs",
		EnableLocalOverride: true,
	}
}

// Load загружает конфигурацию с заданными опциями
func Load(opts *LoadOptions) (*Config, error) {
	if opts == nil {
		opts = DefaultLoadOptions()
	}

	// Определяем окружение
	env := opts.Environment
	if env == "" {
		envStr := os.Getenv("APP_ENV")
		if envStr == "" {
			envStr = "dev"
		}
		env = Environment(envStr)
	}

	configMu.Lock()
	defer configMu.Unlock()

	currentEnv = env

	// 1. Загружаем value.toml (базовые константы)
	valuePath := filepath.Join(opts.ConfigDir, "value.toml")
	value := &Value{}
	if _, err := os.Stat(valuePath); err == nil {
		if _, err := toml.DecodeFile(valuePath, value); err != nil {
			return nil, fmt.Errorf("декодирование value.toml: %w", err)
		}
	}
	globalValue = value

	// 2. Загружаем конфиг окружения
	cfg := &Config{}
	envPath := filepath.Join(opts.ConfigDir, fmt.Sprintf("config_%s.toml", env))
	if _, err := toml.DecodeFile(envPath, cfg); err != nil {
		return nil, fmt.Errorf("декодирование config_%s.toml: %w", env, err)
	}

	// 3. Загружаем локальные переопределения (опционально)
	if opts.EnableLocalOverride {
		localPath := filepath.Join(opts.ConfigDir, "config_local.toml")
		if _, err := os.Stat(localPath); err == nil {
			if _, err := toml.DecodeFile(localPath, cfg); err != nil {
				return nil, fmt.Errorf("декодирование config_local.toml: %w", err)
			}
		}
	}

	globalConfig = cfg

	return cfg, nil
}

// MustLoad загружает конфигурацию или паникует при ошибке
func MustLoad(opts *LoadOptions) *Config {
	cfg, err := Load(opts)
	if err != nil {
		panic(fmt.Sprintf("ошибка загрузки конфига: %v", err))
	}
	return cfg
}

// Get возвращает текущий конфиг (потокобезопасно)
func Get() *Config {
	configMu.RLock()
	defer configMu.RUnlock()
	return globalConfig
}

// GetValue возвращает константные значения (потокобезопасно)
func GetValue() *Value {
	configMu.RLock()
	defer configMu.RUnlock()
	return globalValue
}

// GetEnv возвращает текущее окружение
func GetEnv() Environment {
	configMu.RLock()
	defer configMu.RUnlock()
	return currentEnv
}

// IsProduction возвращает true если работаем в production
func IsProduction() bool {
	return GetEnv() == EnvProduction
}

// IsDevelopment возвращает true если работаем в dev или local
func IsDevelopment() bool {
	env := GetEnv()
	return env == EnvDev || env == EnvLocal
}
