// Code generated by configgen. DO NOT EDIT.
// Код сгенерирован configgen. НЕ РЕДАКТИРОВАТЬ.

package config

import (
	"fmt"
	"os"
	"path/filepath"
	"strings"
	"sync"

	"github.com/knadh/koanf/parsers/toml/v2"
	kenv "github.com/knadh/koanf/providers/env"
	"github.com/knadh/koanf/providers/file"
	"github.com/knadh/koanf/v2"
)

var (
	allConfigs map[Environment]*Config
	configMu   sync.RWMutex
	currentEnv Environment
)

// LoadOptions настраивает загрузку конфигурации
type LoadOptions struct {
	// ConfigDir директория с файлами конфигурации
	ConfigDir string

	// Environment окружение для загрузки (local, dev, stg, prod)
	// Если пусто, читается из переменной окружения APP_ENV
	Environment Environment

	// EnableOverride позволяет override.toml переопределять значения текущего окружения
	EnableOverride bool

	// EnableEnv позволяет env vars переопределять значения из файлов
	// Разделитель секций — двойное подчёркивание (__), одинарное (_) сохраняется
	// Пример: APP_SERVER__HOST=localhost переопределяет server.host
	// Пример: APP_DB__MAX_OPEN_CONNS=10 переопределяет db.max_open_conns
	EnableEnv bool
}

// Load загружает все конфигурации окружений и выбирает нужную
// Порядок мержа для каждого env: value.toml -> config_{env}.toml
// Для текущего env дополнительно: -> override.toml (если EnableOverride=true)
func Load(opts *LoadOptions) (*Config, error) {
	if opts == nil {
		opts = &LoadOptions{
			ConfigDir:      "./configs",
			EnableOverride: true,
		}
	}

	env := opts.Environment
	if env == "" {
		envStr := os.Getenv("APP_ENV")
		if envStr == "" {
			envStr = "dev"
		}
		env = Environment(envStr)
	}

	valuePath := filepath.Join(opts.ConfigDir, "value.toml")
	hasValue := fileExists(valuePath)

	// Находим все config_*.toml (каждый = отдельное окружение)
	matches, err := filepath.Glob(filepath.Join(opts.ConfigDir, "config_*.toml"))
	if err != nil {
		return nil, fmt.Errorf("поиск конфигов: %w", err)
	}

	configs := make(map[Environment]*Config)

	needReload := opts.EnableOverride || opts.EnableEnv

	for _, match := range matches {
		envName := envFromFilename(filepath.Base(match))

		if needReload && Environment(envName) == env {
			continue
		}

		cfg, err := loadSingle(valuePath, hasValue, match)
		if err != nil {
			return nil, err
		}
		cfg.Env = Environment(envName)
		configs[cfg.Env] = cfg
	}

	// Для текущего окружения: value.toml → config_{env}.toml → override.toml → env vars
	if needReload {
		envPath := filepath.Join(opts.ConfigDir, fmt.Sprintf("config_%s.toml", env))
		if fileExists(envPath) {
			k := koanf.New(".")

			if hasValue {
				if err := k.Load(file.Provider(valuePath), toml.Parser()); err != nil {
					return nil, fmt.Errorf("загрузка value.toml: %w", err)
				}
			}

			if err := k.Load(file.Provider(envPath), toml.Parser()); err != nil {
				return nil, fmt.Errorf("загрузка config_%s.toml: %w", env, err)
			}

			if opts.EnableOverride {
				overridePath := filepath.Join(opts.ConfigDir, "override.toml")
				if fileExists(overridePath) {
					if err := k.Load(file.Provider(overridePath), toml.Parser()); err != nil {
						return nil, fmt.Errorf("загрузка override.toml: %w", err)
					}
				}
			}

			if opts.EnableEnv {
				envPrefix := "APP_"
				if err := k.Load(kenv.Provider(envPrefix, ".", func(s string) string {
					// APP_SERVER__HOST -> server.host
					// APP_DB__MAX_IDLE_TIME -> db.max_idle_time
					s = strings.TrimPrefix(s, envPrefix)
					s = strings.ToLower(s)
					s = strings.ReplaceAll(s, "__", ".")
					return s
				}), nil); err != nil {
					return nil, fmt.Errorf("загрузка env vars: %w", err)
				}
			}

			cfg := &Config{}
			if err := k.UnmarshalWithConf("", cfg, koanf.UnmarshalConf{Tag: "toml"}); err != nil {
				return nil, fmt.Errorf("декодирование конфига: %w", err)
			}
			cfg.Env = env
			configs[env] = cfg
		}
	}

	current := configs[env]
	if current == nil {
		return nil, fmt.Errorf("конфиг для окружения %q не найден", env)
	}

	configMu.Lock()
	allConfigs = configs
	currentEnv = env
	configMu.Unlock()

	return current, nil
}

// loadSingle загружает один конфиг: value.toml + config_{env}.toml
func loadSingle(valuePath string, hasValue bool, envPath string) (*Config, error) {
	k := koanf.New(".")

	if hasValue {
		if err := k.Load(file.Provider(valuePath), toml.Parser()); err != nil {
			return nil, fmt.Errorf("загрузка value.toml: %w", err)
		}
	}

	if err := k.Load(file.Provider(envPath), toml.Parser()); err != nil {
		return nil, fmt.Errorf("загрузка %s: %w", filepath.Base(envPath), err)
	}

	cfg := &Config{}
	if err := k.UnmarshalWithConf("", cfg, koanf.UnmarshalConf{Tag: "toml"}); err != nil {
		return nil, fmt.Errorf("декодирование %s: %w", filepath.Base(envPath), err)
	}
	return cfg, nil
}

func envFromFilename(name string) string {
	return strings.TrimSuffix(strings.TrimPrefix(name, "config_"), ".toml")
}

func fileExists(path string) bool {
	_, err := os.Stat(path)
	return err == nil
}

// MustLoad загружает конфигурацию или паникует при ошибке
func MustLoad(opts *LoadOptions) *Config {
	cfg, err := Load(opts)
	if err != nil {
		panic(fmt.Sprintf("ошибка загрузки конфига: %v", err))
	}
	return cfg
}

// Get возвращает текущий конфиг (потокобезопасно)
func Get() *Config {
	configMu.RLock()
	defer configMu.RUnlock()
	return allConfigs[currentEnv]
}

// GetEnv возвращает текущее окружение
func GetEnv() Environment {
	configMu.RLock()
	defer configMu.RUnlock()
	return currentEnv
}

// GetAll возвращает конфиги всех окружений
func GetAll() map[Environment]*Config {
	configMu.RLock()
	defer configMu.RUnlock()
	return allConfigs
}

// IsProduction возвращает true если работаем в production
func IsProduction() bool {
	return GetEnv() == EnvProduction
}

// IsStg возвращает true если работаем в staging
func IsStg() bool {
	return GetEnv() == EnvStaging
}

// IsLocal возвращает true если работаем локально
func IsLocal() bool {
	return GetEnv() == EnvLocal
}
