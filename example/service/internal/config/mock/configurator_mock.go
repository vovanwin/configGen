// Code generated by http://github.com/gojuno/minimock (v3.4.7). DO NOT EDIT.

package mock

import (
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/gojuno/minimock/v3"
)

// ConfiguratorMock implements mm_config.Configurator
type ConfiguratorMock struct {
	t          minimock.Tester
	finishOnce sync.Once

	funcGetEnv          func() (s1 string)
	funcGetEnvOrigin    string
	inspectFuncGetEnv   func()
	afterGetEnvCounter  uint64
	beforeGetEnvCounter uint64
	GetEnvMock          mConfiguratorMockGetEnv

	funcIsLocal          func() (b1 bool)
	funcIsLocalOrigin    string
	inspectFuncIsLocal   func()
	afterIsLocalCounter  uint64
	beforeIsLocalCounter uint64
	IsLocalMock          mConfiguratorMockIsLocal

	funcIsProduction          func() (b1 bool)
	funcIsProductionOrigin    string
	inspectFuncIsProduction   func()
	afterIsProductionCounter  uint64
	beforeIsProductionCounter uint64
	IsProductionMock          mConfiguratorMockIsProduction

	funcIsStg          func() (b1 bool)
	funcIsStgOrigin    string
	inspectFuncIsStg   func()
	afterIsStgCounter  uint64
	beforeIsStgCounter uint64
	IsStgMock          mConfiguratorMockIsStg
}

// NewConfiguratorMock returns a mock for mm_config.Configurator
func NewConfiguratorMock(t minimock.Tester) *ConfiguratorMock {
	m := &ConfiguratorMock{t: t}

	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.GetEnvMock = mConfiguratorMockGetEnv{mock: m}

	m.IsLocalMock = mConfiguratorMockIsLocal{mock: m}

	m.IsProductionMock = mConfiguratorMockIsProduction{mock: m}

	m.IsStgMock = mConfiguratorMockIsStg{mock: m}

	t.Cleanup(m.MinimockFinish)

	return m
}

type mConfiguratorMockGetEnv struct {
	optional           bool
	mock               *ConfiguratorMock
	defaultExpectation *ConfiguratorMockGetEnvExpectation
	expectations       []*ConfiguratorMockGetEnvExpectation

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// ConfiguratorMockGetEnvExpectation specifies expectation struct of the Configurator.GetEnv
type ConfiguratorMockGetEnvExpectation struct {
	mock *ConfiguratorMock

	results      *ConfiguratorMockGetEnvResults
	returnOrigin string
	Counter      uint64
}

// ConfiguratorMockGetEnvResults contains results of the Configurator.GetEnv
type ConfiguratorMockGetEnvResults struct {
	s1 string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGetEnv *mConfiguratorMockGetEnv) Optional() *mConfiguratorMockGetEnv {
	mmGetEnv.optional = true
	return mmGetEnv
}

// Expect sets up expected params for Configurator.GetEnv
func (mmGetEnv *mConfiguratorMockGetEnv) Expect() *mConfiguratorMockGetEnv {
	if mmGetEnv.mock.funcGetEnv != nil {
		mmGetEnv.mock.t.Fatalf("ConfiguratorMock.GetEnv mock is already set by Set")
	}

	if mmGetEnv.defaultExpectation == nil {
		mmGetEnv.defaultExpectation = &ConfiguratorMockGetEnvExpectation{}
	}

	return mmGetEnv
}

// Inspect accepts an inspector function that has same arguments as the Configurator.GetEnv
func (mmGetEnv *mConfiguratorMockGetEnv) Inspect(f func()) *mConfiguratorMockGetEnv {
	if mmGetEnv.mock.inspectFuncGetEnv != nil {
		mmGetEnv.mock.t.Fatalf("Inspect function is already set for ConfiguratorMock.GetEnv")
	}

	mmGetEnv.mock.inspectFuncGetEnv = f

	return mmGetEnv
}

// Return sets up results that will be returned by Configurator.GetEnv
func (mmGetEnv *mConfiguratorMockGetEnv) Return(s1 string) *ConfiguratorMock {
	if mmGetEnv.mock.funcGetEnv != nil {
		mmGetEnv.mock.t.Fatalf("ConfiguratorMock.GetEnv mock is already set by Set")
	}

	if mmGetEnv.defaultExpectation == nil {
		mmGetEnv.defaultExpectation = &ConfiguratorMockGetEnvExpectation{mock: mmGetEnv.mock}
	}
	mmGetEnv.defaultExpectation.results = &ConfiguratorMockGetEnvResults{s1}
	mmGetEnv.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmGetEnv.mock
}

// Set uses given function f to mock the Configurator.GetEnv method
func (mmGetEnv *mConfiguratorMockGetEnv) Set(f func() (s1 string)) *ConfiguratorMock {
	if mmGetEnv.defaultExpectation != nil {
		mmGetEnv.mock.t.Fatalf("Default expectation is already set for the Configurator.GetEnv method")
	}

	if len(mmGetEnv.expectations) > 0 {
		mmGetEnv.mock.t.Fatalf("Some expectations are already set for the Configurator.GetEnv method")
	}

	mmGetEnv.mock.funcGetEnv = f
	mmGetEnv.mock.funcGetEnvOrigin = minimock.CallerInfo(1)
	return mmGetEnv.mock
}

// Times sets number of times Configurator.GetEnv should be invoked
func (mmGetEnv *mConfiguratorMockGetEnv) Times(n uint64) *mConfiguratorMockGetEnv {
	if n == 0 {
		mmGetEnv.mock.t.Fatalf("Times of ConfiguratorMock.GetEnv mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetEnv.expectedInvocations, n)
	mmGetEnv.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmGetEnv
}

func (mmGetEnv *mConfiguratorMockGetEnv) invocationsDone() bool {
	if len(mmGetEnv.expectations) == 0 && mmGetEnv.defaultExpectation == nil && mmGetEnv.mock.funcGetEnv == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetEnv.mock.afterGetEnvCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetEnv.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetEnv implements mm_config.Configurator
func (mmGetEnv *ConfiguratorMock) GetEnv() (s1 string) {
	mm_atomic.AddUint64(&mmGetEnv.beforeGetEnvCounter, 1)
	defer mm_atomic.AddUint64(&mmGetEnv.afterGetEnvCounter, 1)

	mmGetEnv.t.Helper()

	if mmGetEnv.inspectFuncGetEnv != nil {
		mmGetEnv.inspectFuncGetEnv()
	}

	if mmGetEnv.GetEnvMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetEnv.GetEnvMock.defaultExpectation.Counter, 1)

		mm_results := mmGetEnv.GetEnvMock.defaultExpectation.results
		if mm_results == nil {
			mmGetEnv.t.Fatal("No results are set for the ConfiguratorMock.GetEnv")
		}
		return (*mm_results).s1
	}
	if mmGetEnv.funcGetEnv != nil {
		return mmGetEnv.funcGetEnv()
	}
	mmGetEnv.t.Fatalf("Unexpected call to ConfiguratorMock.GetEnv.")
	return
}

// GetEnvAfterCounter returns a count of finished ConfiguratorMock.GetEnv invocations
func (mmGetEnv *ConfiguratorMock) GetEnvAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetEnv.afterGetEnvCounter)
}

// GetEnvBeforeCounter returns a count of ConfiguratorMock.GetEnv invocations
func (mmGetEnv *ConfiguratorMock) GetEnvBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetEnv.beforeGetEnvCounter)
}

// MinimockGetEnvDone returns true if the count of the GetEnv invocations corresponds
// the number of defined expectations
func (m *ConfiguratorMock) MinimockGetEnvDone() bool {
	if m.GetEnvMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetEnvMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetEnvMock.invocationsDone()
}

// MinimockGetEnvInspect logs each unmet expectation
func (m *ConfiguratorMock) MinimockGetEnvInspect() {
	for _, e := range m.GetEnvMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to ConfiguratorMock.GetEnv")
		}
	}

	afterGetEnvCounter := mm_atomic.LoadUint64(&m.afterGetEnvCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetEnvMock.defaultExpectation != nil && afterGetEnvCounter < 1 {
		m.t.Errorf("Expected call to ConfiguratorMock.GetEnv at\n%s", m.GetEnvMock.defaultExpectation.returnOrigin)
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetEnv != nil && afterGetEnvCounter < 1 {
		m.t.Errorf("Expected call to ConfiguratorMock.GetEnv at\n%s", m.funcGetEnvOrigin)
	}

	if !m.GetEnvMock.invocationsDone() && afterGetEnvCounter > 0 {
		m.t.Errorf("Expected %d calls to ConfiguratorMock.GetEnv at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.GetEnvMock.expectedInvocations), m.GetEnvMock.expectedInvocationsOrigin, afterGetEnvCounter)
	}
}

type mConfiguratorMockIsLocal struct {
	optional           bool
	mock               *ConfiguratorMock
	defaultExpectation *ConfiguratorMockIsLocalExpectation
	expectations       []*ConfiguratorMockIsLocalExpectation

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// ConfiguratorMockIsLocalExpectation specifies expectation struct of the Configurator.IsLocal
type ConfiguratorMockIsLocalExpectation struct {
	mock *ConfiguratorMock

	results      *ConfiguratorMockIsLocalResults
	returnOrigin string
	Counter      uint64
}

// ConfiguratorMockIsLocalResults contains results of the Configurator.IsLocal
type ConfiguratorMockIsLocalResults struct {
	b1 bool
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmIsLocal *mConfiguratorMockIsLocal) Optional() *mConfiguratorMockIsLocal {
	mmIsLocal.optional = true
	return mmIsLocal
}

// Expect sets up expected params for Configurator.IsLocal
func (mmIsLocal *mConfiguratorMockIsLocal) Expect() *mConfiguratorMockIsLocal {
	if mmIsLocal.mock.funcIsLocal != nil {
		mmIsLocal.mock.t.Fatalf("ConfiguratorMock.IsLocal mock is already set by Set")
	}

	if mmIsLocal.defaultExpectation == nil {
		mmIsLocal.defaultExpectation = &ConfiguratorMockIsLocalExpectation{}
	}

	return mmIsLocal
}

// Inspect accepts an inspector function that has same arguments as the Configurator.IsLocal
func (mmIsLocal *mConfiguratorMockIsLocal) Inspect(f func()) *mConfiguratorMockIsLocal {
	if mmIsLocal.mock.inspectFuncIsLocal != nil {
		mmIsLocal.mock.t.Fatalf("Inspect function is already set for ConfiguratorMock.IsLocal")
	}

	mmIsLocal.mock.inspectFuncIsLocal = f

	return mmIsLocal
}

// Return sets up results that will be returned by Configurator.IsLocal
func (mmIsLocal *mConfiguratorMockIsLocal) Return(b1 bool) *ConfiguratorMock {
	if mmIsLocal.mock.funcIsLocal != nil {
		mmIsLocal.mock.t.Fatalf("ConfiguratorMock.IsLocal mock is already set by Set")
	}

	if mmIsLocal.defaultExpectation == nil {
		mmIsLocal.defaultExpectation = &ConfiguratorMockIsLocalExpectation{mock: mmIsLocal.mock}
	}
	mmIsLocal.defaultExpectation.results = &ConfiguratorMockIsLocalResults{b1}
	mmIsLocal.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmIsLocal.mock
}

// Set uses given function f to mock the Configurator.IsLocal method
func (mmIsLocal *mConfiguratorMockIsLocal) Set(f func() (b1 bool)) *ConfiguratorMock {
	if mmIsLocal.defaultExpectation != nil {
		mmIsLocal.mock.t.Fatalf("Default expectation is already set for the Configurator.IsLocal method")
	}

	if len(mmIsLocal.expectations) > 0 {
		mmIsLocal.mock.t.Fatalf("Some expectations are already set for the Configurator.IsLocal method")
	}

	mmIsLocal.mock.funcIsLocal = f
	mmIsLocal.mock.funcIsLocalOrigin = minimock.CallerInfo(1)
	return mmIsLocal.mock
}

// Times sets number of times Configurator.IsLocal should be invoked
func (mmIsLocal *mConfiguratorMockIsLocal) Times(n uint64) *mConfiguratorMockIsLocal {
	if n == 0 {
		mmIsLocal.mock.t.Fatalf("Times of ConfiguratorMock.IsLocal mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmIsLocal.expectedInvocations, n)
	mmIsLocal.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmIsLocal
}

func (mmIsLocal *mConfiguratorMockIsLocal) invocationsDone() bool {
	if len(mmIsLocal.expectations) == 0 && mmIsLocal.defaultExpectation == nil && mmIsLocal.mock.funcIsLocal == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmIsLocal.mock.afterIsLocalCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmIsLocal.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// IsLocal implements mm_config.Configurator
func (mmIsLocal *ConfiguratorMock) IsLocal() (b1 bool) {
	mm_atomic.AddUint64(&mmIsLocal.beforeIsLocalCounter, 1)
	defer mm_atomic.AddUint64(&mmIsLocal.afterIsLocalCounter, 1)

	mmIsLocal.t.Helper()

	if mmIsLocal.inspectFuncIsLocal != nil {
		mmIsLocal.inspectFuncIsLocal()
	}

	if mmIsLocal.IsLocalMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmIsLocal.IsLocalMock.defaultExpectation.Counter, 1)

		mm_results := mmIsLocal.IsLocalMock.defaultExpectation.results
		if mm_results == nil {
			mmIsLocal.t.Fatal("No results are set for the ConfiguratorMock.IsLocal")
		}
		return (*mm_results).b1
	}
	if mmIsLocal.funcIsLocal != nil {
		return mmIsLocal.funcIsLocal()
	}
	mmIsLocal.t.Fatalf("Unexpected call to ConfiguratorMock.IsLocal.")
	return
}

// IsLocalAfterCounter returns a count of finished ConfiguratorMock.IsLocal invocations
func (mmIsLocal *ConfiguratorMock) IsLocalAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmIsLocal.afterIsLocalCounter)
}

// IsLocalBeforeCounter returns a count of ConfiguratorMock.IsLocal invocations
func (mmIsLocal *ConfiguratorMock) IsLocalBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmIsLocal.beforeIsLocalCounter)
}

// MinimockIsLocalDone returns true if the count of the IsLocal invocations corresponds
// the number of defined expectations
func (m *ConfiguratorMock) MinimockIsLocalDone() bool {
	if m.IsLocalMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.IsLocalMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.IsLocalMock.invocationsDone()
}

// MinimockIsLocalInspect logs each unmet expectation
func (m *ConfiguratorMock) MinimockIsLocalInspect() {
	for _, e := range m.IsLocalMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to ConfiguratorMock.IsLocal")
		}
	}

	afterIsLocalCounter := mm_atomic.LoadUint64(&m.afterIsLocalCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.IsLocalMock.defaultExpectation != nil && afterIsLocalCounter < 1 {
		m.t.Errorf("Expected call to ConfiguratorMock.IsLocal at\n%s", m.IsLocalMock.defaultExpectation.returnOrigin)
	}
	// if func was set then invocations count should be greater than zero
	if m.funcIsLocal != nil && afterIsLocalCounter < 1 {
		m.t.Errorf("Expected call to ConfiguratorMock.IsLocal at\n%s", m.funcIsLocalOrigin)
	}

	if !m.IsLocalMock.invocationsDone() && afterIsLocalCounter > 0 {
		m.t.Errorf("Expected %d calls to ConfiguratorMock.IsLocal at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.IsLocalMock.expectedInvocations), m.IsLocalMock.expectedInvocationsOrigin, afterIsLocalCounter)
	}
}

type mConfiguratorMockIsProduction struct {
	optional           bool
	mock               *ConfiguratorMock
	defaultExpectation *ConfiguratorMockIsProductionExpectation
	expectations       []*ConfiguratorMockIsProductionExpectation

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// ConfiguratorMockIsProductionExpectation specifies expectation struct of the Configurator.IsProduction
type ConfiguratorMockIsProductionExpectation struct {
	mock *ConfiguratorMock

	results      *ConfiguratorMockIsProductionResults
	returnOrigin string
	Counter      uint64
}

// ConfiguratorMockIsProductionResults contains results of the Configurator.IsProduction
type ConfiguratorMockIsProductionResults struct {
	b1 bool
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmIsProduction *mConfiguratorMockIsProduction) Optional() *mConfiguratorMockIsProduction {
	mmIsProduction.optional = true
	return mmIsProduction
}

// Expect sets up expected params for Configurator.IsProduction
func (mmIsProduction *mConfiguratorMockIsProduction) Expect() *mConfiguratorMockIsProduction {
	if mmIsProduction.mock.funcIsProduction != nil {
		mmIsProduction.mock.t.Fatalf("ConfiguratorMock.IsProduction mock is already set by Set")
	}

	if mmIsProduction.defaultExpectation == nil {
		mmIsProduction.defaultExpectation = &ConfiguratorMockIsProductionExpectation{}
	}

	return mmIsProduction
}

// Inspect accepts an inspector function that has same arguments as the Configurator.IsProduction
func (mmIsProduction *mConfiguratorMockIsProduction) Inspect(f func()) *mConfiguratorMockIsProduction {
	if mmIsProduction.mock.inspectFuncIsProduction != nil {
		mmIsProduction.mock.t.Fatalf("Inspect function is already set for ConfiguratorMock.IsProduction")
	}

	mmIsProduction.mock.inspectFuncIsProduction = f

	return mmIsProduction
}

// Return sets up results that will be returned by Configurator.IsProduction
func (mmIsProduction *mConfiguratorMockIsProduction) Return(b1 bool) *ConfiguratorMock {
	if mmIsProduction.mock.funcIsProduction != nil {
		mmIsProduction.mock.t.Fatalf("ConfiguratorMock.IsProduction mock is already set by Set")
	}

	if mmIsProduction.defaultExpectation == nil {
		mmIsProduction.defaultExpectation = &ConfiguratorMockIsProductionExpectation{mock: mmIsProduction.mock}
	}
	mmIsProduction.defaultExpectation.results = &ConfiguratorMockIsProductionResults{b1}
	mmIsProduction.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmIsProduction.mock
}

// Set uses given function f to mock the Configurator.IsProduction method
func (mmIsProduction *mConfiguratorMockIsProduction) Set(f func() (b1 bool)) *ConfiguratorMock {
	if mmIsProduction.defaultExpectation != nil {
		mmIsProduction.mock.t.Fatalf("Default expectation is already set for the Configurator.IsProduction method")
	}

	if len(mmIsProduction.expectations) > 0 {
		mmIsProduction.mock.t.Fatalf("Some expectations are already set for the Configurator.IsProduction method")
	}

	mmIsProduction.mock.funcIsProduction = f
	mmIsProduction.mock.funcIsProductionOrigin = minimock.CallerInfo(1)
	return mmIsProduction.mock
}

// Times sets number of times Configurator.IsProduction should be invoked
func (mmIsProduction *mConfiguratorMockIsProduction) Times(n uint64) *mConfiguratorMockIsProduction {
	if n == 0 {
		mmIsProduction.mock.t.Fatalf("Times of ConfiguratorMock.IsProduction mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmIsProduction.expectedInvocations, n)
	mmIsProduction.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmIsProduction
}

func (mmIsProduction *mConfiguratorMockIsProduction) invocationsDone() bool {
	if len(mmIsProduction.expectations) == 0 && mmIsProduction.defaultExpectation == nil && mmIsProduction.mock.funcIsProduction == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmIsProduction.mock.afterIsProductionCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmIsProduction.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// IsProduction implements mm_config.Configurator
func (mmIsProduction *ConfiguratorMock) IsProduction() (b1 bool) {
	mm_atomic.AddUint64(&mmIsProduction.beforeIsProductionCounter, 1)
	defer mm_atomic.AddUint64(&mmIsProduction.afterIsProductionCounter, 1)

	mmIsProduction.t.Helper()

	if mmIsProduction.inspectFuncIsProduction != nil {
		mmIsProduction.inspectFuncIsProduction()
	}

	if mmIsProduction.IsProductionMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmIsProduction.IsProductionMock.defaultExpectation.Counter, 1)

		mm_results := mmIsProduction.IsProductionMock.defaultExpectation.results
		if mm_results == nil {
			mmIsProduction.t.Fatal("No results are set for the ConfiguratorMock.IsProduction")
		}
		return (*mm_results).b1
	}
	if mmIsProduction.funcIsProduction != nil {
		return mmIsProduction.funcIsProduction()
	}
	mmIsProduction.t.Fatalf("Unexpected call to ConfiguratorMock.IsProduction.")
	return
}

// IsProductionAfterCounter returns a count of finished ConfiguratorMock.IsProduction invocations
func (mmIsProduction *ConfiguratorMock) IsProductionAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmIsProduction.afterIsProductionCounter)
}

// IsProductionBeforeCounter returns a count of ConfiguratorMock.IsProduction invocations
func (mmIsProduction *ConfiguratorMock) IsProductionBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmIsProduction.beforeIsProductionCounter)
}

// MinimockIsProductionDone returns true if the count of the IsProduction invocations corresponds
// the number of defined expectations
func (m *ConfiguratorMock) MinimockIsProductionDone() bool {
	if m.IsProductionMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.IsProductionMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.IsProductionMock.invocationsDone()
}

// MinimockIsProductionInspect logs each unmet expectation
func (m *ConfiguratorMock) MinimockIsProductionInspect() {
	for _, e := range m.IsProductionMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to ConfiguratorMock.IsProduction")
		}
	}

	afterIsProductionCounter := mm_atomic.LoadUint64(&m.afterIsProductionCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.IsProductionMock.defaultExpectation != nil && afterIsProductionCounter < 1 {
		m.t.Errorf("Expected call to ConfiguratorMock.IsProduction at\n%s", m.IsProductionMock.defaultExpectation.returnOrigin)
	}
	// if func was set then invocations count should be greater than zero
	if m.funcIsProduction != nil && afterIsProductionCounter < 1 {
		m.t.Errorf("Expected call to ConfiguratorMock.IsProduction at\n%s", m.funcIsProductionOrigin)
	}

	if !m.IsProductionMock.invocationsDone() && afterIsProductionCounter > 0 {
		m.t.Errorf("Expected %d calls to ConfiguratorMock.IsProduction at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.IsProductionMock.expectedInvocations), m.IsProductionMock.expectedInvocationsOrigin, afterIsProductionCounter)
	}
}

type mConfiguratorMockIsStg struct {
	optional           bool
	mock               *ConfiguratorMock
	defaultExpectation *ConfiguratorMockIsStgExpectation
	expectations       []*ConfiguratorMockIsStgExpectation

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// ConfiguratorMockIsStgExpectation specifies expectation struct of the Configurator.IsStg
type ConfiguratorMockIsStgExpectation struct {
	mock *ConfiguratorMock

	results      *ConfiguratorMockIsStgResults
	returnOrigin string
	Counter      uint64
}

// ConfiguratorMockIsStgResults contains results of the Configurator.IsStg
type ConfiguratorMockIsStgResults struct {
	b1 bool
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmIsStg *mConfiguratorMockIsStg) Optional() *mConfiguratorMockIsStg {
	mmIsStg.optional = true
	return mmIsStg
}

// Expect sets up expected params for Configurator.IsStg
func (mmIsStg *mConfiguratorMockIsStg) Expect() *mConfiguratorMockIsStg {
	if mmIsStg.mock.funcIsStg != nil {
		mmIsStg.mock.t.Fatalf("ConfiguratorMock.IsStg mock is already set by Set")
	}

	if mmIsStg.defaultExpectation == nil {
		mmIsStg.defaultExpectation = &ConfiguratorMockIsStgExpectation{}
	}

	return mmIsStg
}

// Inspect accepts an inspector function that has same arguments as the Configurator.IsStg
func (mmIsStg *mConfiguratorMockIsStg) Inspect(f func()) *mConfiguratorMockIsStg {
	if mmIsStg.mock.inspectFuncIsStg != nil {
		mmIsStg.mock.t.Fatalf("Inspect function is already set for ConfiguratorMock.IsStg")
	}

	mmIsStg.mock.inspectFuncIsStg = f

	return mmIsStg
}

// Return sets up results that will be returned by Configurator.IsStg
func (mmIsStg *mConfiguratorMockIsStg) Return(b1 bool) *ConfiguratorMock {
	if mmIsStg.mock.funcIsStg != nil {
		mmIsStg.mock.t.Fatalf("ConfiguratorMock.IsStg mock is already set by Set")
	}

	if mmIsStg.defaultExpectation == nil {
		mmIsStg.defaultExpectation = &ConfiguratorMockIsStgExpectation{mock: mmIsStg.mock}
	}
	mmIsStg.defaultExpectation.results = &ConfiguratorMockIsStgResults{b1}
	mmIsStg.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmIsStg.mock
}

// Set uses given function f to mock the Configurator.IsStg method
func (mmIsStg *mConfiguratorMockIsStg) Set(f func() (b1 bool)) *ConfiguratorMock {
	if mmIsStg.defaultExpectation != nil {
		mmIsStg.mock.t.Fatalf("Default expectation is already set for the Configurator.IsStg method")
	}

	if len(mmIsStg.expectations) > 0 {
		mmIsStg.mock.t.Fatalf("Some expectations are already set for the Configurator.IsStg method")
	}

	mmIsStg.mock.funcIsStg = f
	mmIsStg.mock.funcIsStgOrigin = minimock.CallerInfo(1)
	return mmIsStg.mock
}

// Times sets number of times Configurator.IsStg should be invoked
func (mmIsStg *mConfiguratorMockIsStg) Times(n uint64) *mConfiguratorMockIsStg {
	if n == 0 {
		mmIsStg.mock.t.Fatalf("Times of ConfiguratorMock.IsStg mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmIsStg.expectedInvocations, n)
	mmIsStg.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmIsStg
}

func (mmIsStg *mConfiguratorMockIsStg) invocationsDone() bool {
	if len(mmIsStg.expectations) == 0 && mmIsStg.defaultExpectation == nil && mmIsStg.mock.funcIsStg == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmIsStg.mock.afterIsStgCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmIsStg.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// IsStg implements mm_config.Configurator
func (mmIsStg *ConfiguratorMock) IsStg() (b1 bool) {
	mm_atomic.AddUint64(&mmIsStg.beforeIsStgCounter, 1)
	defer mm_atomic.AddUint64(&mmIsStg.afterIsStgCounter, 1)

	mmIsStg.t.Helper()

	if mmIsStg.inspectFuncIsStg != nil {
		mmIsStg.inspectFuncIsStg()
	}

	if mmIsStg.IsStgMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmIsStg.IsStgMock.defaultExpectation.Counter, 1)

		mm_results := mmIsStg.IsStgMock.defaultExpectation.results
		if mm_results == nil {
			mmIsStg.t.Fatal("No results are set for the ConfiguratorMock.IsStg")
		}
		return (*mm_results).b1
	}
	if mmIsStg.funcIsStg != nil {
		return mmIsStg.funcIsStg()
	}
	mmIsStg.t.Fatalf("Unexpected call to ConfiguratorMock.IsStg.")
	return
}

// IsStgAfterCounter returns a count of finished ConfiguratorMock.IsStg invocations
func (mmIsStg *ConfiguratorMock) IsStgAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmIsStg.afterIsStgCounter)
}

// IsStgBeforeCounter returns a count of ConfiguratorMock.IsStg invocations
func (mmIsStg *ConfiguratorMock) IsStgBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmIsStg.beforeIsStgCounter)
}

// MinimockIsStgDone returns true if the count of the IsStg invocations corresponds
// the number of defined expectations
func (m *ConfiguratorMock) MinimockIsStgDone() bool {
	if m.IsStgMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.IsStgMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.IsStgMock.invocationsDone()
}

// MinimockIsStgInspect logs each unmet expectation
func (m *ConfiguratorMock) MinimockIsStgInspect() {
	for _, e := range m.IsStgMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to ConfiguratorMock.IsStg")
		}
	}

	afterIsStgCounter := mm_atomic.LoadUint64(&m.afterIsStgCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.IsStgMock.defaultExpectation != nil && afterIsStgCounter < 1 {
		m.t.Errorf("Expected call to ConfiguratorMock.IsStg at\n%s", m.IsStgMock.defaultExpectation.returnOrigin)
	}
	// if func was set then invocations count should be greater than zero
	if m.funcIsStg != nil && afterIsStgCounter < 1 {
		m.t.Errorf("Expected call to ConfiguratorMock.IsStg at\n%s", m.funcIsStgOrigin)
	}

	if !m.IsStgMock.invocationsDone() && afterIsStgCounter > 0 {
		m.t.Errorf("Expected %d calls to ConfiguratorMock.IsStg at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.IsStgMock.expectedInvocations), m.IsStgMock.expectedInvocationsOrigin, afterIsStgCounter)
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *ConfiguratorMock) MinimockFinish() {
	m.finishOnce.Do(func() {
		if !m.minimockDone() {
			m.MinimockGetEnvInspect()

			m.MinimockIsLocalInspect()

			m.MinimockIsProductionInspect()

			m.MinimockIsStgInspect()
		}
	})
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *ConfiguratorMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *ConfiguratorMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockGetEnvDone() &&
		m.MinimockIsLocalDone() &&
		m.MinimockIsProductionDone() &&
		m.MinimockIsStgDone()
}
