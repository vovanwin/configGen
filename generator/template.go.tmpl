// Code generated by configgen. DO NOT EDIT.
// Код сгенерирован configgen. НЕ РЕДАКТИРОВАТЬ.

package {{ .Package }}

import (
	"fmt"
	"os"
	"path/filepath"
{{- if .NeedsTime }}
	"time"
{{- end }}

	"github.com/BurntSushi/toml"
)

// Key тип для ключей конфигурации
type Key string

func (k Key) String() string { return string(k) }

// Ключи конфигурации
const (
{{- range .Keys }}
{{- if .Comment }}
	{{ comment .Comment }}
{{- end }}
	{{ .Const }} Key = "{{ .Value }}"
{{- end }}
)

// Config хранит конфигурацию приложения
type Config struct {
	data map[string]any
	env  string
}

// Options настройки загрузки
type Options struct {
	Dir    string // Директория с конфигами (default: ./configs)
	Env    string // Окружение (default: из APP_ENV или "dev")
	EnvVar string // Имя переменной окружения (default: APP_ENV)
}

// NewConfig создает и загружает конфигурацию
func NewConfig(opts ...Options) (*Config, error) {
	opt := Options{
		Dir:    "./configs",
		EnvVar: "APP_ENV",
	}
	if len(opts) > 0 {
		if opts[0].Dir != "" {
			opt.Dir = opts[0].Dir
		}
		if opts[0].Env != "" {
			opt.Env = opts[0].Env
		}
		if opts[0].EnvVar != "" {
			opt.EnvVar = opts[0].EnvVar
		}
	}

	// Определяем окружение
	env := opt.Env
	if env == "" {
		env = os.Getenv(opt.EnvVar)
		if env == "" {
			env = "dev"
		}
	}

	data := make(map[string]any)

	// 1. Загружаем value.toml
	valuePath := filepath.Join(opt.Dir, "value.toml")
	if _, err := os.Stat(valuePath); err == nil {
		if err := loadTOML(valuePath, data); err != nil {
			return nil, fmt.Errorf("value.toml: %w", err)
		}
	}

	// 2. Загружаем config_{env}.toml
	envPath := filepath.Join(opt.Dir, fmt.Sprintf("config_%s.toml", env))
	if err := loadTOML(envPath, data); err != nil {
		return nil, fmt.Errorf("config_%s.toml: %w", env, err)
	}

	// 3. Загружаем config_local.toml (если есть)
	localPath := filepath.Join(opt.Dir, "config_local.toml")
	if _, err := os.Stat(localPath); err == nil {
		if err := loadTOML(localPath, data); err != nil {
			return nil, fmt.Errorf("config_local.toml: %w", err)
		}
	}

	return &Config{data: data, env: env}, nil
}

// MustNewConfig создает конфиг или паникует
func MustNewConfig(opts ...Options) *Config {
	cfg, err := NewConfig(opts...)
	if err != nil {
		panic(fmt.Sprintf("config: %v", err))
	}
	return cfg
}

func loadTOML(path string, data map[string]any) error {
	var raw map[string]any
	if _, err := toml.DecodeFile(path, &raw); err != nil {
		return err
	}
	mergeMaps(data, raw)
	return nil
}

func mergeMaps(dst, src map[string]any) {
	for k, v := range src {
		if srcMap, ok := v.(map[string]any); ok {
			if dstMap, ok := dst[k].(map[string]any); ok {
				mergeMaps(dstMap, srcMap)
				continue
			}
		}
		dst[k] = v
	}
}

// Env возвращает текущее окружение
func (c *Config) Env() string { return c.env }

// IsProd возвращает true для production
func (c *Config) IsProd() bool { return c.env == "prod" }

// IsDev возвращает true для dev/local
func (c *Config) IsDev() bool { return c.env == "dev" || c.env == "local" }

// Get возвращает значение по ключу
func (c *Config) Get(key Key) any {
	return getNestedValue(c.data, string(key))
}

func getNestedValue(data map[string]any, key string) any {
	parts := splitKey(key)
	current := any(data)

	for _, part := range parts {
		if m, ok := current.(map[string]any); ok {
			current = m[part]
		} else {
			return nil
		}
	}
	return current
}

func splitKey(key string) []string {
	var parts []string
	var current string
	for _, r := range key {
		if r == '.' {
			if current != "" {
				parts = append(parts, current)
				current = ""
			}
		} else {
			current += string(r)
		}
	}
	if current != "" {
		parts = append(parts, current)
	}
	return parts
}

// --- Методы доступа к значениям ---
{{ range .Keys }}
{{- if .Comment }}
{{ comment .Comment }}
{{- end }}
func (c *Config) {{ .Const }}() {{ .Type }} {
	v := c.Get({{ .Const }})
	if v == nil {
		var zero {{ .Type }}
		return zero
	}
{{- if eq .Type "int" }}
	switch val := v.(type) {
	case int:
		return val
	case int64:
		return int(val)
	case float64:
		return int(val)
	default:
		return 0
	}
{{- else if eq .Type "time.Duration" }}
	if s, ok := v.(string); ok {
		d, _ := time.ParseDuration(s)
		return d
	}
	return 0
{{- else if eq .Type "bool" }}
	if b, ok := v.(bool); ok {
		return b
	}
	return false
{{- else if eq .Type "float64" }}
	if f, ok := v.(float64); ok {
		return f
	}
	return 0
{{- else }}
	if s, ok := v.({{ .Type }}); ok {
		return s
	}
	return ""
{{- end }}
}
{{ end }}
